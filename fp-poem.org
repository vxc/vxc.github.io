#+title:  Functional Programming for no Rhyme or Reason
#+SETUPFILE: ./org-templates/level-0.org

Venkatesh Choppella: 14th May 2019 (tweaked 28th December 2019)
#+begin_verse
----------------------------

=======
Prelude
=======

Coming to IIIT 
this Monsoon season,
Functional Programming
for no Rhyme or Reason.

The Dean might be worried,
that the syllabus lies buried,
in verse,
that is necessarily terse.

But, for students in class,
that are bored or sleepy,
or think functional programming
is crazy and creepy,
I made up this jingle
hoping it'll tingle
their curiosity
and coding velocity.

Not to mention, the faculty,
and curriculum designers, who are wary.  
What is functional programming?
And why is it so scary?
I'd rather teach Python or C!
Can't have programming
turn into algebra, you see!

=============================================
Functional Programming for no Rhyme or Reason
=============================================

Expressions have Meaning.
The Meaning is Contextual.

Programs are Expressions,
Expressions are reducible.
In the crucible of the Interpreter,
the Meaning is deducible. 

Syntax is superficial.
Pick one
that's easy 'n sensible.
While you're at it, 
it may, for good measure,
be extensible.

Values are what you have,
when Expressions are normalizable. 
Identifiable and immutable.
Plain and irreducible,
Their existence, irrefutable. 

Semantics is simplificational,
compositional and substitutional.
Depending on what you like,
axiomatic, operational or denotational.

Bindings are persistent, 
and lexical.
Those recursive? Circular,
and paradoxical.

For, circularity and self-application,
you conclude, after  some meditation, 
are at the heart of 
Recursive Functions that are Nameless.
and except when baseless (or tasteless),
are begotten, you realise somewhat later
from  Y, the mysterious
Fixed Point combinator.

Referential transparency,
is not about efficiency.
Young Man!
'Tis a Call to Reason!
Unlike Assignment, 
which is forbidden,
and tantamount to treason!

Still, if Effects is what want you might,
Try this thing called Monadic.
I'm told they're  tricky to get right, 
it's best when they are sporadic.

Functions are values,
applicable, and higher-order.
It's what let's you write
programs that are shorter. 

Functions have Types.
Types are polymorphic.
And isomorphic, 
to propositions,
that are logical.
Programs are like proofs, 
of theorems  mathematical.

The moral of this allegory:
Lambda is a Category,
that is closed and Cartesian.
If you don't believe me,
check with a logician,
or a type theoretician.


Iteration is Recursion. 
Recursion in tail position. 
Recursion is Iteration,
just pass the Continuation!

Be warned! In calling with
the current continuation, 
exercise considerable caution, 
lest there is confusion, 
or a catastrophic situation! 

An Object is a Closure.
(I learned this from a Hoosier.)
Formals, body and  bindings of
free variables that are mutable.
Methods are functions over Self,
in a position that's suitable. 

Data is algebraic, and inductive.
Processes, co-algebraic, and co-inductive.
Now, just in case, 
you find  this
so charming and seductive,
there's also reasoning
that's abductive and deductive.

Logic is Magic.
Magic is Logic. 
Ask Smullyan, who did both,
besides Puzzles and Music.


Application is Evaluation.
Abstraction is Implication.
Value the destination,
by most estimation. 

Alpha is permutable.
Beta, Eta, the ritual.
Lambda, the Ultimate.
and Omega, the perpetual.

``You know its value,
but do you know its cost?'' 
Laments the Garbage Collector, 
(the Solitary Sweeper?)
and borrows from Frost:
The lists are lovely, long and deep,
But I have promised to mark the Heap,
And bytes to go before I sweep.
And bytes to go before I sweep.


Ah, a whole class in verse!
Now, isn't that perverse?
But,  what is a program,
if not a poem?
At least, this is what
I wish to show 'em.


I could go on
and on,
waxing along,
right or wrong.
But now it's time
to close this song. 
A functional program 
would never be so long.
#+end_verse


